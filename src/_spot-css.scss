/// SPOT CSS Framework
/// { Single Place Of Truth CSS Methodology }
///
/// @author Johnny Seyd (johnnyseyd@gmail.com)
/// @link https://github.com/seyd/spot-css
///
$SPOT-CSS-FRAMEWORK: '1.0';
//
// Usage:
//    @import "./path/to/spot-css";


/// Main top-level mixin to define component.
///
/// 1) It checks if same component is defined multiple times. It is not allowed because Single Place Of Truth.
///
/// 2) Components can be nested one into another.
///
/// @group Component
/// @access public
/// @param { String } $selector - single selector of component
/// @content
/// @throw SPOT CSS: component/no selector - selector was expected but nothing passed.
/// @throw SPOT CSS: component/single selector - given selector is not a single selector ({selector}).
/// @throw SPOT CSS: component/already registered - given selector is already registered as component ({selector}).
/// @output Given selector with given content.
@mixin component($selector) {
    @if not $selector or $selector=="" {
        @error $SPOT_ERROR_PREFIX + "component/no selector - selector was expected but nothing passed.";
    }

    $selectors: selector-parse($selector);
    @if length($selectors)>1 {
        @error $SPOT_ERROR_PREFIX + "component/single selector - given selector is not a single selector ('"+$selector+"').";
    }
    
    $component-selector: $selector;

    $already-registered: index($_registered-components, $component-selector)!=null;

    // 1)
    @if $already-registered {
        @error $SPOT_ERROR_PREFIX + "component/already registered - given selector is already registered as component ('"+$component-selector+"').";
    }
    @else {
        // store component selector if is not stored yet
        $_registered-components: append($_registered-components, $component-selector, 'comma') !global;
    }

    // 2)
    // store current component selector (into stack)
    $_current-components: append($_current-components, $component-selector, 'space') !global;

    #{$component-selector} {
        @content;
    }

    // remove current component selector (from stack)
    $_current-components: pop($_current-components) !global;
}


/// @group Component
/// @access public
/// @return { String } Current component selector.
@function component() {
    @return #{$_current-components}; 
}


/// @group Component
/// @access public
/// @return { String } Current single component selector (the last one if nested).
@function current-single-component() {
    @return #{last($_current-components)}; 
}


/// Main top-level mixin to define component.
/// @group Component
/// @access public
/// @content
/// @throw SPOT CSS: register/no component - the mixin register must be used inside a component.
/// @output Given selector with given content.
@mixin register {
    @if component()=='' {
        @error $SPOT_ERROR_PREFIX + "register/no component - the mixin register must be used inside a component.";
    }
    $_is-register-mode: true !global;
    @content;
    $_is-register-mode: false !global;
}


/// This mixins works in 2 modes:
///
/// 1) when used in register mixin, it will register variation in current component.
///
/// 2) when used outside of register mixin, it will apply given variation(s) to current component selector.
///
/// @group Component
/// @access public
/// @param { String } $args... - In register mode it require variation selector (and all values when placeholder '?' is used in variation selector) OR when not in regiter mode selector extension(s) = variation names
/// @content
/// @throw In register mode see errors of mixin _register-modifiers and mixin _register-individual-modifier OR when not in regiter mode see errors of mixin _apply-modifier
/// @output In register mode outputs nothing OR when not in regiter mode it will output selector extended by given variation(s) with given content.
@mixin variation($args...) {
    @if $_is-register-mode {        
        @include _register-modifiers('variation', $args...);
    }
    @else {
        @include _apply-modifier('variation', $args...) {        
            @content;
        }
    }   
}


/// Same as mixin <b>variation</b> but different semantic naming.
/// @see {mixin} variation
/// @group Component
/// @access public
/// @param { String } $args...
/// @content
@mixin state($args...) {
    @if $_is-register-mode {        
        @include _register-modifiers('state', $args...);
    }
    @else {
        @include _apply-modifier('state', $args...) {        
            @content;
        }
    }   
}


/// This mixins works in 2 modes:
///
/// 1) when used in register mixin, it will register context in current component.
///
/// 2) when used outside of register mixin, it will apply given context(s) to current component selector.
///
/// @group Component
/// @access public
/// @param { String } $args... - In register mode it require context selector and optional alias OR when not in regiter mode selector extension(s) = context names
/// @content
/// @throw In register mode see errors of mixin _register-modifiers and mixin _register-individual-modifier OR when not in regiter mode see errors of mixin _apply-modifier
/// @output In register mode outputs nothing OR when not in regiter mode it will output selector extended by given context(s) with given content.
@mixin context($args...) {
    @if $_is-register-mode {
        // ' &' appendix signalize different mode of  composint selector
        @include _register-modifiers('context &', $args...);
    }
    @else {
        // ' &' appendix signalize different mode of  composint selector
        @include _apply-modifier('context &', $args...) {        
            @content;
        }
    }   
}


/// Same as mixin <b>context</b> but different semantic naming.
/// @see {mixin} context
/// @group Component
/// @access public
/// @param { String } $args...
/// @content
@mixin browser($args...) {
    @if $_is-register-mode {
        // ' &' appendix signalize different mode of  composint selector
        @include _register-modifiers('browser &', $args...);
    }
    @else {
        // ' &' appendix signalize different mode of  composint selector
        @include _apply-modifier('browser &', $args...) {        
            @content;
        }
    }   
}

/// Same as mixin <b>context</b> but different semantic naming.
/// @see {mixin} context
/// @group Component
/// @access public
/// @param { String } $args...
/// @content
@mixin responsive($args...) {
    @if $_is-register-mode {
        // ' &' appendix signalize different mode of  composint selector
        @include _register-modifiers('responsive &', $args...);
    }
    @else {
        // ' &' appendix signalize different mode of  composint selector
        @include _apply-modifier('responsive &', $args...) {        
            @content;
        }
    }   
}


/// Declares direct child block in current component selector.
/// @group Component
/// @access public
/// @param { String } $args... - One or more selectors of direct childs. Each selector as a single selector in separate argument.
/// @content
/// @throw SPOT CSS: child-element/no selectors - at least one child selector is expected.
/// @throw SPOT CSS: child-element/single selector - given selector is not a single selector ('selector'). Just pass it as a separate argument.
/// @throw SPOT CSS: child-element/multilevel selector - given selector is not a single selector ('selector'). Just use more child-element mixins nested.
/// @output Given selector with given content.
@mixin child-element($args...) {
    @if length($args)==0 {
        @error $SPOT_ERROR_PREFIX + "child-element/no selectors - at least one child selector is expected.";
    }
    $selectors: (); 
    @each $selector in $args {
        $parts: selector-parse($selector);
        // @feature Forcing using only single selector in one selector string. It could be passed more selectors in separate arguments.
        @if length($parts)>1 {
            @error $SPOT_ERROR_PREFIX + "child-element/single selector - given selector is not a single selector ('"+$selector+"'). Just pass it as a separate argument.";
        }        
        // all child selectors must start with >
        @if str-index(str-trim-left($selector), '>')!=1 and str-last-char(#{&})!='>' {
            $selector: '> '+$selector;
        }
        // @feature Guarding that only first (one) level child selector is passed.
        // Value 2 because also starting '>' is counted
        @if length-of-simple-selector($selector)>2 {
            @error $SPOT_ERROR_PREFIX + "child-element/multilevel selector - given selector is not a single selector ('"+$selector+"'). Just use more child-element mixins nested.";
        }   
        $selectors: append($selectors, $selector, 'comma');
    }
    #{$selectors} {
        @content;
    }
}


/// Declares any other then child block in current component selector. 
/// It is same as child-element mixin, but it does not force direct child selector (>) and
/// it could contain multilevel selectors also (e.g. 'div a.disabled span').
/// Note: It is strongly recomended to use <b>child-element</b> mixin everytime it is possible!
/// @group Component
/// @access public
/// @param { String } $args... - One or more selectors. Each selector as a single selector in separate argument.
/// @content
/// @throw SPOT CSS: sub-element/no selectors - at least one selector is expected.
/// @throw SPOT CSS: sub-element/single selector - given selector is not a single selector ('selector'). Just pass it as a separate argument.
/// @output Given selector with given content.
@mixin sub-element($args...) {
    @if length($args)==0 {
        @error $SPOT_ERROR_PREFIX + "sub-element/no selectors - at least one selector is expected.";
    }
    $selectors: (); 
    @each $selector in $args {
        $parts: selector-parse($selector);
        // @feature Forcing using only single selector in one selector string. It could be passed more selectors in separate arguments.
        @if length($parts)>1 {
            @error $SPOT_ERROR_PREFIX + "sub-element/single selector - given selector is not a single selector ('"+$selector+"'). Just pass it as a separate argument.";
        }        
        $selectors: append($selectors, $selector, 'comma');
    }
    #{$selectors} {
        @content;
    }
}


/// Declares pseudo element(s) of current component selector.
/// @group Component
/// @access public
/// @param { String } $first - pseudo selector 'before' or 'after' (also prefixes ':' and ':: are accepted)
/// @param { String } $second - pseudo selector 'before' or 'after' (also prefixes ':' and ':: are accepted)
/// @content
/// @throw SPOT CSS: pseudo-element/no selectors - at least one pseudo selector is expected ('before' or 'after').
/// @throw SPOT CSS: pseudo-element/invalid selector - only valid values are 'before' or 'after' (if both, pass it as separate arguments).
/// @throw SPOT CSS: pseudo-element/invalid selectors - only valid values are 'before' or 'after' (if both, pass it as separate arguments).
/// @output Given selector with given content.
@mixin pseudo-element($first: '', $second: '') {
    @if not $first or $first=='' {
        @error $SPOT_ERROR_PREFIX + "pseudo-element/no selectors - at least one pseudo selector is expected ('before' or 'after').";
    }
    // replace all colons (':' and '::')
    $first: str-trim(str-replace($first, ':', ''));
    $second: str-trim(str-replace($second, ':', ''));

    @if $first!='before' and $first!='after' {
        @error $SPOT_ERROR_PREFIX + "pseudo-element/invalid selector - only valid values are 'before' or 'after' (if both, pass it as separate arguments).";
    }

    @if $second and $second!='' and $second!='before' and $second!='after' {
        @error $SPOT_ERROR_PREFIX + "pseudo-element/invalid selectors - only valid values are 'before' or 'after' (if both, pass it as separate arguments).";
    }

    @if not $second or $second=='' {
        &::#{$first} {
            @content;
        }
    }
    @else {
        &::#{$first}, &::#{$second} {
            @content;
        }
    }
}


/// Tests if given selector contains pseudo element 'before' or 'after'.
/// @access public
/// @param { String } $selector - single selector
/// @return { Bool } True if contains pseudo element
@function contains-pseudo-element($selector) {
    $last-selector: nth($selector, length($selector));
    @return str-index($last-selector, ':before')!=null or str-index($last-selector, ':after')!=null;
}


/// Add selector specificity at element level.
/// @access public
/// @param { Number } $n - How many levels to add (1..n)
/// @content
/// @output Stronger selector(s) with given inner content.
@mixin add-element-specificity($n) {
    @at-root #{add-element-specificity(&, $n)} {
        @content;
    }
}


/// Add selector specificity at class level.
/// @access public
/// @param { Number } $n - How many levels to add (1..n)
/// @content
/// @output Stronger selector(s) with given inner content.
@mixin add-class-specificity($n) {
    @at-root #{add-class-specificity(&, $n)} {
        @content;
    }
}


/// Add selector specificity at id level.
/// @access public
/// @param { Number } $n - How many levels to add (1..n)
/// @content
/// @output Stronger selector(s) with given inner content.
@mixin add-id-specificity($n) {
    @at-root #{add-id-specificity(&, $n)} {
        @content;
    }
}


/// Add selector specificity at element level.
/// @access public
/// @param { String } $selector - Selector(s)
/// @param { Number } $n - How many levels to add (1..n)
/// @return Stronger selector(s).
@function add-element-specificity($selector, $n) {
    @return _add-selector-specificity($selector, $n, '_');
}


/// Add selector specificity at class level.
/// @access public
/// @param { String } $selector - Selector(s)
/// @param { Number } $n - How many levels to add (1..n)
/// @return Stronger selector(s).
@function add-class-specificity($selector, $n) {
    @return _add-selector-specificity($selector, $n, '._');
}


/// Add selector specificity at id level.
/// @access public
/// @param { String } $selector - Selector(s)
/// @param { Number } $n - How many levels to add (1..n)
/// @return Stronger selector(s).
@function add-id-specificity($selector, $n) {
    @return _add-selector-specificity($selector, $n, '#_');
}


/// Add selector specificity to override given specificity.
/// It will make same selector specificity plus one extra element specificity to override it.
/// @access public
/// @param { String } $selector - Selector(s)
/// @param { Number } $id-specificity - Specificity of selector on id level
/// @param { Number } $id-specificity - Specificity of selector on id level
/// @return Stronger selector(s).
@function override-selector-specificity($selector, $id-specificity, $class-specificity, $element-specificity) {
    // Forcing using only single selector in one selector string. It could be passed more selectors in separate arguments.
    $parts: selector-parse($selector);
    @if length($parts)>1 {
        @error $SPOT_ERROR_PREFIX + "override-selector-specificity/single selector - given selector is not a single selector ('"+$selector+"'). Just pass it as a separate argument.";
    } 
    $specificity: specificity($selector);
    $id-spec: nth($specificity, 1);
    $class-spec: nth($specificity, 2);
    $element-spec: nth($specificity, 3);

    // minimize useless selector strength
    @if $id-spec > $id-specificity {
        @return $selector;
    }
    @if $id-spec == $id-specificity and $class-spec > $class-specificity {
        @return $selector;
    }
    @if $id-spec == $id-specificity and $class-spec == $class-specificity and $element-spec > $element-specificity {
        @return $selector;
    }

    // element specificity is incremented to make stronger selector 
    $element-specificity: $element-specificity + 1;

    @if $id-specificity > $id-spec {
        $selector: add-id-specificity($selector, $id-specificity - $id-spec);
    }
    @if $class-specificity > $class-spec {
        $selector: add-class-specificity($selector, $class-specificity - $class-spec);
    }
    @if $element-specificity > $element-spec {
        $selector: add-element-specificity($selector, $element-specificity - $element-spec);
    }
    @return $selector;
}

 
/// Returns the specificity map or value of given simple/complex/multiple selector(s).
///
/// (Utility to calculate (and display) specificity or specificity map of any valid simple/compound/complex selector.)
/// @author David Khourshid (https://twitter.com/davidkpiano)
/// @access public
/// @param {List | String} $initial-selector - selector returned by '&'
/// @param {Bool} $integer (false) - output specificity as integer? (default: false)
/// @return {Map | Number} specificity map or specificity value represented as integer
@function specificity($initial-selector, $integer: false) {
    $initial-selector: _str-replace-batch(#{$initial-selector}, ('+', '>', '~'));
    $selectors: selector-parse($initial-selector);
    $specificities-map: ();
    
    @each $selector in $selectors {
        $parts: ();
        $selector-specificity-map: (a: 0, b: 0, c: 0);
        
        @each $simple-selectors in $selector {
            @each $simple-selector in simple-selectors($simple-selectors) {
                $parts: append($parts, $simple-selector);
            }
        }
        
        @each $part in $parts {
            $specificity-type: _specificity-type($part);
            @if $specificity-type {
                $selector-specificity-map: map-merge($selector-specificity-map, (#{$specificity-type}: map-get($selector-specificity-map, $specificity-type) + 1));
            }
        }
        
        $specificities-map: map-merge($specificities-map, (_specificity-value($selector-specificity-map): $selector-specificity-map));
    }
    
    $specificity-value: max(map-keys($specificities-map)...);
    $specificity-map: map-values(map-get($specificities-map, $specificity-value));
    
    @return if($integer, $specificity-value, $specificity-map);
}


/// Outputs specificity in your CSS as (invalid) properties.
/// Please, don't use this mixin in production.
///
/// (Utility to calculate (and display) specificity or specificity map of any valid simple/compound/complex selector.)
/// @author David Khourshid (https://twitter.com/davidkpiano)
/// @access public
/// @output specificity (map as string), specificity-value (specificity value as integer)
@mixin specificity() {
  specificity: specificity(&);
  specificity-value: specificity(&, true);
}


/// Override current selector over given selector.
/// @access public
/// @param { String } $args... - Selector(s) to override
/// @content
/// @output Stronger selector(s) with given inner content.
@mixin override($args...) {
    @at-root #{override(&, $args...)} {
        @content;
    }
}


/// Override current selector over given selector.
/// @access public
/// @param { String } $current-selector - Selector(s) to be strengthen
/// @param { String } $args... - Selector(s) to override
/// @return Stronger selector(s).
@function override($current-selector, $args...) {
    // find strongest specificity in $args
    $strongest-specificity: 0;
    $strongest-selector: null;
    @each $selector in $args {
        $parts: selector-parse($selector);
        // @feature Forcing using only single selector in one selector string. It could be passed more selectors in separate arguments.
        @if length($parts)>1 {
            @error $SPOT_ERROR_PREFIX + "override/single selector - given selector is not a single selector ('"+$selector+"'). Just pass it as a separate argument.";
        }        
        $specificity: specificity($selector, true);
        @if $specificity > $strongest-specificity {
            $strongest-specificity: $specificity;
            $strongest-selector: $selector;
        }
    }
    // calculate specificity of the strongest selector
    $specificity: specificity($strongest-selector);
    $id-specificity: nth($specificity, 1);
    $class-specificity: nth($specificity, 2);
    $element-specificity: nth($specificity, 3);
   
    // for each selector
    $selectors: selector-parse($current-selector);
    $output: (); 
    @each $selector in $selectors {
        $selector: override-selector-specificity($selector, $id-specificity, $class-specificity, $element-specificity);
        $output: append($output, $selector, 'comma');
    }
    @return #{$output};
}


/// Filter given selector with given sub-selectors.
/// Every selector which does not contain any of given args will be excluded.
/// @access public
/// @param { String } $args... - Selector(s) to override
/// @content
/// @output Filtered selector(s) with given inner content.
@mixin for-branch($args...) {
    @at-root #{for-branch(&, $args...)} {
        @content;
    }
}


/// Filter given selector with given sub-selectors.
/// Every selector which does not contain any of given args will be excluded.
/// @access public
/// @param { String } $current-selector - Selector(s) to be strengthen
/// @param { String } $args... - Selector(s) to override
/// @return Filtered selector(s).
@function for-branch($selector, $args...) {
    $selectors: selector-parse($selector);
    $output: (); 
    $found: false;
    @each $selector in $selectors {
        $match: false;
        @each $branch in $args {
            @if str-index(to-string($selector), $branch) {
                $match: true;
                $found: true;
            }
        }
        @if $match {
            $output: append($output, $selector, 'comma');
        }
    }
    @if not $found {
        @error $SPOT_ERROR_PREFIX + "for-branch/not found - given branch selector was not found at the end of current selector ('"+$selector+"').";
    }
    @return #{$output};
}



// ------------------------------------------------------------------------------------------------
// --- HELPERS ------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------



/// @todo tests
@function extend($selector, $something, $extension) {
    // for each selector (if more selectors in $selector) check if extended selector is present
    @each $single-selector in $selector {
        @if str-index($single-selector+'', $something+'')==null {
            @error 'Extend function has failed! Subselector "'+$something+'" was not found in selector "'+$single-selector+'".';
        }
    }  
    // if more selector in $extension, breaks it and replace each individual
    // it makes from ($something: '.item', $extenssion: '':first-child, :last-child') => $new-extension: 'item:first-child, item:last-child'
    $parts: selector-parse($extension);
    $new-extension: ();
    @each $partial-selector in $parts {
        $partial-selector: selector-replace($partial-selector, $partial-selector, $something + $partial-selector);
        $new-extension: append($new-extension, $partial-selector, 'comma');
    }
    // now it is safe to use selector-replace
    @return selector-replace($selector, $something, $new-extension+''); // +'' = convert to string
}


/// @todo tests
// test if selector contains simple subselector
@function selector-contains($selector, $simple-sub-selector) {
    $selectors: selector-parse($selector);
    @each $single-selector in $selectors {
        @each $part-selector in $single-selector {
            @if is-superselector($simple-sub-selector, $part-selector) {
                @return true;
            }
        }
    }
    @return false;
}


@function first($list) {
    @return nth($list, 1);
}


@function last($list) {
    @return nth($list, length($list));
}


// @description Complementary to append() function.
@function prepend($list, $value) {
    @return join($value, $list);
}


// @description Remove the last item in the list (opposite of append() function).
// @returns new list, not last item (to do so use last() function)
@function pop($list) {
    $result: ();
    $len: length($list);
    @if $len>1 {
        @for $i from 1 through $len - 1 {
            $result: append($result, nth($list, $i));
        }
    }
    @return $result;
}


@function str-replace($string, $search, $replace: '') {
    $index: str-index($string, $search);
    
    @if $index {
      @return str-slice($string, 1, $index - 1) + $replace + str-replace(str-slice($string, $index + str-length($search)), $search, $replace);
    }
    
    @return $string;
  }


@function str-trim-left($s) {
    @while (str-index($s, ' ')==1) {
        $i: str-index($s, ' ');
        $s: "#{str-slice($s, 0, $i - 1)}#{str-slice($s, $i + 1)}";
    }
    @return $s;
}


@function str-trim-right($s) {
    @while (str-slice($s, str-length($s))==' ') {
        $i: str-index($s, ' ');
        $s: "#{str-slice($s, 0, $i - 1)}#{str-slice($s, $i + 1)}";
    }
    @return $s;
}


@function str-trim($s) {
    @return str-trim-left(str-trim-right($s));
}


@function str-last-char($s) {
    @return str-slice(str-trim-right($s), -1);
}

// It has to be simple selector (not contain comma separated selectors)
// @return How many selector levels given selector contains.
// @example:
//  'a.link' => 1 
//  'a.link span' => 2
//  'a.link + span' => 3
//  '> a.link' => 2
@function length-of-simple-selector($selector) {
    @return length(nth(selector-parse($selector),1));
}


@function to-string($value) {
    @return inspect($value);
}


@function pow($number, $exponent) {
    $value: 1;
    @if $exponent > 0 {
        @for $i from 1 through $exponent {
        $value: $value * $number;
        }
    }
    @return $value;
}



// ------------------------------------------------------------------------------------------------
// --- PRIVATE ------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------



/// Prefix of the SPOT CSS Framework errors.
/// @access private
/// @type String
$SPOT_ERROR_PREFIX: "SPOT CSS: ";


/// Map of registered components.
/// @group Component
/// @access private
/// @type Map
$_registered-components: ();


/// Current component or stack of current components (if multiple are nested).
/// @group Component
/// @access private
/// @type Map
$_current-components: ();

/// Flag of register mode - if parser enters mixin register.
/// @group Component
/// @access private
/// @type Bool
$_is-register-mode: false;


/// Map of registered modifiers, e.g. state, variation, context, ...
/// @group Component
/// @access private
/// @type Map
$_registered-modifiers: ();


/// List of registered identifiers for guarding uniqueness (per component).
/// @group Component
/// @access private
/// @type List
$_registered-identifierss: [];


/// List of registered aliases of identifiers for guarding uniqueness (per component).
/// @group Component
/// @access private
/// @type List
$_registered-aliases: [];


/// Create unique string for combination $component + $identifier.
/// @group Component
/// @access private
/// @return { String } Unique string identifier.
@function _get-component-identifier($component, $identifier) {
    @return $component+'---'+$identifier;
}


/// Create unique string for combination $component + $modifier.
/// @group Component
/// @access private
/// @return { String } Unique string modifier.
@function _get-component-modifier($component, $modifier) {
    @return $component+'___'+$modifier;
}


/// Reusable mixin for registering states, variations, contexts, browsers, responsive...
/// @group Component
/// @access private
/// @param { String } $modifier-name - 'state' | 'variation' | 'context' | 'browser' | 'responsive'
/// @param { String } $identifier - selector extension
/// @param { String } $args... - extra arguments for input values for placeholder '?' or alias name when context-like modifier ('context' | 'browser' | 'responsive')
/// @throw SPOT CSS: register/placeholder in context - the mixin register { modifier-name(identifier) } uses '?' as value placeholder but for context-like modifiers it is not supported (it supports only extra alias param).
/// @throw SPOT CSS: register/missing values - the mixin register { modifier-name(identifier) } uses '?' as value placeholder but no values were provided.
/// @throw SPOT CSS: register/extra values - the mixin register { modifier-name(identifier) } doesn't use '?' as value placeholder but extra values were provided.
/// @output Nothing.
@mixin _register-modifiers($modifier-name, $identifier, $args...) { 
    @if component()=='' {
        @error $SPOT_ERROR_PREFIX + "register/no component - the mixin register { "+$modifier-name+"("+$identifier+") } must be used inside a component selector.";
    }
    // if selector contains '?' (e.g. '[type="?"]') character, $args must be provided as expected values
    // expample arguments: ('state', '[type="?"]', 'primary', 'secondary')
    @if str-index($identifier, '?') or str-index($identifier, '{') {

        // if context-like modifier then placeholder '?' is not supported
        @if str-index($modifier-name, '&') {
            @error $SPOT_ERROR_PREFIX + "register/placeholder in context - the mixin register { "+$modifier-name+"("+$identifier+") } uses '?' as value placeholder but for context-like modifiers it is not supported (it supports only extra alias param).";
        }

        $len: length($args);
        @if $len==0 {
            @error $SPOT_ERROR_PREFIX + "register/missing values - the mixin register { "+$modifier-name+"("+$identifier+") } uses '?' as value placeholder but no values were provided.";
        }
        @else {
            $alias: $identifier;
            $placeholder-start: str-index($identifier, '?') or str-index($identifier, '{');
            $placeholder-end: str-index($identifier, '?') or str-index($identifier, '}');
            // register modifier for each given value individualy
            @for $i from 1 through $len {                 
                $selector: str-slice($identifier, 1, $placeholder-start - 1) + nth($args, $i) + str-slice($identifier, $placeholder-end + 1 );
                @include _register-individual-modifier($modifier-name, $selector, $alias, $do-not-check-alias: $i!=1); // check alias only for first modifier
            }
        }
    }
    // if selector does not contains "?" character, $args must be not provided (as expected values)
    @else {
        // if extra values and not context-like modifier (it accepts extra $alias param)
        @if $args!=null and length($args)!=0 and not str-index($modifier-name, '&') {
            @error $SPOT_ERROR_PREFIX + "register/extra values - the mixin register { "+$modifier-name+"("+$identifier+") } doesn't use '?' as value placeholder but extra values were provided.";
        }
        @else {
            // register modifier
            @include _register-individual-modifier($modifier-name, $identifier, $args...);
        }
    }
}


/// Reusable mixin for registering state, variation, context, browser or responsive.
/// @group Component
/// @access private
/// @param { String } $modifier-name - 'state' | 'variation' | 'context' | 'browser' | 'responsive'
/// @param { String } $identifier - selector extension
/// @param { String } $alias - alias name when context-like modifier ('context' | 'browser' | 'responsive')
/// @param { Bool } $do-not-check-alias - flag to skip duplicity check for aliases
/// @throw SPOT CSS: register/duplicate modifier - trying to register already registered modifier 'identifier' for component 'component'.
/// @throw SPOT CSS: register/duplicate modifier with alias - trying to register modifier 'identifier' but there is already registered modifier with same alias for component 'component'.
/// @throw SPOT CSS: register/duplicate alias with modifier - trying to register alias 'alias' but there is already registered same modifier for component 'component'.
/// @throw SPOT CSS: register/duplicate modifier alias - trying to register already registered modifier alias 'alias' for component 'component'.
/// @output Nothing.
@mixin _register-individual-modifier($modifier-name, $identifier, $alias: '', $do-not-check-alias: false) {    
    // backup
    $original-identifier: $identifier;    

    $identifier: _add-default-ampersand-if-context($modifier-name, $identifier);
    $alias_with_ampersand: _add-default-ampersand-if-context($modifier-name, $alias);
    $current-component: component(); 

    // create unique identifier of component+identifier
    $component-with-identifier: _get-component-identifier($current-component, $identifier);

    // create unique modifier of component+modifier-name (without ' &' appendix)
    $component-with-modifier: str-replace(_get-component-modifier($current-component, $modifier-name), ' &', '');

    // @feature Guarding duplicity of modifiers
    @if index($_registered-identifierss, $component-with-identifier) {
        @error $SPOT_ERROR_PREFIX + "register/duplicate modifier - trying to register already registered modifier '"+$original-identifier+"' for component '"+$current-component+"'.";
    }

    // @feature Guarding duplicity of modifiers with aliases
    @if index($_registered-aliases, _get-component-identifier($current-component, $original-identifier)) {
        @error $SPOT_ERROR_PREFIX + "register/duplicate modifier with alias - trying to register modifier '"+$original-identifier+"' but there is already registered modifier with same alias for component '"+$current-component+"'.";
    }

    // store unique identifier
    $_registered-identifierss: append($_registered-identifierss, $component-with-identifier) !global;

    @if $alias and $alias!='' and not $do-not-check-alias {
        // @feature Guarding duplicity of alias with modifiers
        @if index($_registered-identifierss, _get-component-identifier($current-component, $alias_with_ampersand)) {
            @error $SPOT_ERROR_PREFIX + "register/duplicate alias with modifier - trying to register alias '"+$alias+"' but there is already registered same modifier for component '"+$current-component+"'.";
        }

        // create unique identifier of component+identifier
        $component-with-alias: _get-component-identifier($current-component, $alias);
    
        // @feature Guarding duplicity of modifiers aliases
        @if index($_registered-aliases, $component-with-alias) {
            @error $SPOT_ERROR_PREFIX + "register/duplicate modifier alias - trying to register already registered modifier alias '"+$alias+"' for component '"+$current-component+"'.";
        }

        // store unique alias
        $_registered-aliases: append($_registered-aliases, $component-with-alias) !global;    
    }
    
    // create empty map if does not existes yet
    @if not map-has-key($_registered-modifiers, $component-with-modifier) {
        $_registered-modifiers: map-merge($_registered-modifiers, ($component-with-modifier: ())) !global;
    }
    // get current map for given modifier
    $new-modifier: map-get($_registered-modifiers, $component-with-modifier);
    // add new modifier identifier
    $new-modifier: map-merge($new-modifier, ($identifier: (alias: $alias)));
    // merge it back to complex map
    $_registered-modifiers: map-merge($_registered-modifiers, ($component-with-modifier: $new-modifier)) !global; 
}


/// Reusable mixin for applying states, variations, contexts, browsers, responsive...
/// @group Component
/// @access private
/// @param { String } $modifier-name - 'state' | 'variation' | 'context' | 'browser' | 'responsive'
/// @param { String } $args... - selector extension(s)
/// @content
/// @throw SPOT CSS: register/wrong modifier type - the modifier 'identifier' is not registered in component 'current selector' as 'modifier-name'. Check it out!
/// @throw SPOT CSS: register/unknown modifier - the 'modifier-name' 'identifier' is not registered in component 'current selector'. Use mixin register-state() at first!
/// @output Selector extended by given extensions with given content.
@mixin _apply-modifier($modifier-name, $args...) {
    $selectors: (); 
    $component: component();

    @each $identifier in $args {
        $original-identifier: $identifier;
        $identifier: _add-default-ampersand-if-context($modifier-name, $identifier);
        $component-with-identifier: _get-component-identifier($component, $identifier);
        $component-with-modifier: str-replace(_get-component-modifier($component, $modifier-name), ' &', '');
        $modifiers: map-get($_registered-modifiers, $component-with-modifier);
        $is-alias: index($_registered-aliases, str-replace($component-with-identifier, ' &', ''));
        @if $is-alias {
            @if $modifiers {
                // find all modifiers with this alias
                @each $modifier in $modifiers {
                    $alias: map-get(nth($modifier, 2), 'alias');
                    @if $original-identifier==$alias {
                        $extension: nth($modifier, 1);
                        $extended-selector: '';
                        @if str-index($extension, '&') {
                            $extended-selector: $extension;
                        }
                        @else {
                            $extended-selector: extend(&, current-single-component(), $extension);
                        }
                        $selectors: append($selectors, $extended-selector, 'comma');
                    }                
                }
            }
            @if length($selectors)==0 {
                // @feature Forcing to register all modifiers at first
                @error $SPOT_ERROR_PREFIX + "register/wrong modifier type - the modifier '"+$identifier+"' is not registered in component '"+&+"' as "+$modifier-name+". Check it out!";
            }
        }
        // if not alias - just $identifier
        @else {
            @if $modifiers!=null and map-has-key($modifiers, $identifier) {
                $extension: $identifier;
                $extended-selector: '';                
                @if str-index($extension, '&') {
                    $extended-selector: $extension;
                }
                @else {
                    $extended-selector: extend(&, current-single-component(), $extension);
                }
                $selectors: append($selectors, $extended-selector, 'comma');
            }
            @else {
                // @feature Forcing to register all modifiers at first
                @error $SPOT_ERROR_PREFIX + "register/unknown modifier - the "+$modifier-name+" '"+$identifier+"' is not registered in component '"+&+"'. Use mixin register-state() at first!";
            }
        }
    }        
    @at-root #{$selectors} {
        @content;
    }
}


/// @todo tests
/// @access private
@function _add-default-ampersand-if-context($modifier-name, $identifier) {
    @if str-index($modifier-name, '&') and not str-index($identifier, '&') {
        // when selector does not define '&' implicitly, it add it on the end of selector by default
        @return $identifier + ' &';
    }
    @else {
        @return $identifier;
    }
}


// add selector specificity at `given` level
@function _add-selector-specificity($selector, $n, $not-what-mark) {
    $selectors: selector-parse($selector);
    $output: ();
    $addon: '';
    @for $i from 1 to $n+1 {
        $addon: $addon + ':not(' + $not-what-mark + ')';
    }
    // for each selector (if more selectors in $selector)
    @each $single-selector in $selectors {
        $single-selector: to-string($single-selector);
        @if str-index($single-selector, ':before')!=null {
            $single-selector: str-replace(str-replace($single-selector, '::before', ''), ':before', '');
            $single-selector: $single-selector + $addon + '::before';
        }
        @else if str-index($single-selector, ':after')!=null {
            $single-selector: str-replace(str-replace($single-selector, '::after', ''), ':after', '');
            $single-selector: $single-selector + $addon + '::after';
        }
        @else {
            $single-selector: $single-selector + $addon;
        }
        $output: append($output, $single-selector, 'comma');
    }
    @return #{$output};
}

 
/// SCSS Specificity Calculator
///
/// Replaces a batch of substrings (needles) in a string (haystack)
/// with a single replacement string.
///
/// (Utility to calculate (and display) specificity or specificity map of any valid simple/compound/complex selector.)
/// @author David Khourshid (https://twitter.com/davidkpiano)
/// @access private
/// @param {String} $haystack - string to perform search and replacement on
/// @param {List | String} $needles - string or list of strings to replace globally
/// @param {String} $replacement ('') - replacement string to replace needles
/// @return {String} replaced string
@function _str-replace-batch($haystack, $needles, $replacement: '') {
    $instances: false;
    
    @if not type_of($needles) == list { $needles: ($needles); }
    
    @while ($instances == false) or ($instances > 0) {
        $instances: 0;
        
        @each $needle in $needles {
            $needle-index: str-index($haystack, $needle);
            $instances: $instances + if($needle-index, 1, 0);
            
            @if $needle-index {
                $haystack: str-slice($haystack, 1, $needle-index - 1) + str-slice($haystack, $needle-index + str-length($needle), -1);
                $haystack: str-insert($haystack, $replacement, $needle-index);
            }
        }
    }
    
    @return $haystack;
}
 

/// Signifies what specificity type the simple selector is.
/// a - IDs
/// b - class selectors, attribute selectors, pseudo-classes
/// c - type (element) selectors, pseudo-elements
///
/// (Utility to calculate (and display) specificity or specificity map of any valid simple/compound/complex selector.)
/// @author David Khourshid (https://twitter.com/davidkpiano)
/// @access private
/// @param {String} $simple-selector - a single simple selector
/// @return {String} specificity type of simple selector - 'a', 'b', 'c', or false
@function _specificity-type($simple-selector) {
    $types: (
        c: (':before', ':after', ':first-line', ':first-letter', ':selection'),
        b: ('.', '[', ':'),
        a: ('#')
    );
    
    $simple-selector: _str-replace-batch($simple-selector, '::', ':');
    
    @if str-index($simple-selector, ':not(') == 1 {
        $simple-selector: str-slice($simple-selector, 6, -2);
    }
    
    @each $type-key, $type-tokens in $types {
        @each $token in $type-tokens {
            @if str-index($simple-selector, $token) == 1 {
                @return $type-key;
            }
        }
    }
    
    // Ignore the universal selector
    @if str-index($simple-selector, '*') == 1 {
        @return false;
    }
    
    // Simple selector is type selector (element)
    @return c;
}

 
/// Returns the specificity value (in the specified base).
/// Base is set to 256 (16^2) to accurately represent historical 6-digit
/// hexadecimal representation of specificity in most browsers, though this
/// limitation has been "resolved" in some browsers (try base 65536 for those).
///
/// (Utility to calculate (and display) specificity or specificity map of any valid simple/compound/complex selector.)
/// @author David Khourshid (https://twitter.com/davidkpiano)
/// @access private
/// @param {Map} $specificity-map - map of frequency of each type (a, b, c) in complex selector
/// @param {Number} $base (256) - base used to calculate specificity value (default: 256)
/// @return {Number} specificity value of given specificity map as base 10 integer
@function _specificity-value($specificity-map, $base: 256) {
    $exponent-map: (a: 2, b: 1, c: 0);
    $specificity: 0;
    
    @each $specificity-type, $specificity-value in $specificity-map {
        $specificity: $specificity + ($specificity-value * pow($base, map-get($exponent-map, $specificity-type)));
    }
    
    @return $specificity;
}